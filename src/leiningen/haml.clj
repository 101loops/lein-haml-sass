(ns leiningen.haml
  (:use leiningen.lein-haml.file-utils)
  (:require [clojure.java.io :as io]
            [leiningen.help :as lhelp]
            ;;[leiningen.core.main :as main]
            )
  (:import [org.jruby.embed ScriptingContainer LocalContextScope]))

(def c (ScriptingContainer. LocalContextScope/THREADSAFE))
(.runScriptlet c "require 'rubygems'; require 'haml'")

(def ^:private engineclass (.runScriptlet c "Haml::Engine"))

(defn- render [template]
  (let [engine (.callMethod c engineclass "new" template Object)]
    (.callMethod c engine "render" String)))

(defn- render-all! [{:keys [haml-src output-directory output-extension auto-compile-delay]} watch?]
  (loop []
    (doseq [haml-descriptor (haml-dest-files-from haml-src {:dest output-directory :ext output-extension})]
      (let [dest-file (io/file (:dest haml-descriptor))
            haml-file (io/file (:haml haml-descriptor))]
        (when (or (not (.exists dest-file))
                  (> (.lastModified haml-file) (.lastModified dest-file)))
          (io/make-parents dest-file)
          (spit dest-file (render (slurp (:haml haml-descriptor))))
          (println (str "   [haml] - " (java.util.Date.) " - " haml-file " -> " dest-file )))))

    (when watch?
      (Thread/sleep auto-compile-delay)
      (recur))))



(defn- normalize-options [options]
  (merge {:haml-src "resources/haml"
          :output-extension "html"
          :delete-output-dir true
          :auto-compile-delay 250}
         options))

(defn- extract-options [project]
  (when (nil? (:haml project))
    (println "WARNING: no :haml entry found in project definition."))
  (normalize-options (:haml project)))


(defn- once
  "Compiles the haml files once"
  [options]
  (println (str "Compiling haml files in " (:haml-src options)))
  (render-all! options false))

(defn- auto
  "Automatically recompiles when files are "
  [options]
  (println (str "Ready to compile haml located in " (:haml-src options)))
  (render-all! options true))

(defn- clean
  "Removes the autogenerated files"
  [{:keys [haml-src output-directory output-extension delete-output-dir]}]
  (doseq [haml-descriptor (haml-dest-files-from haml-src {:dest output-directory :ext output-extension})]
    (delete-file! (io/file (:dest haml-descriptor))))
  (when (and delete-output-dir (dir-empty? output-directory))
    (println (str "Destination folder " output-directory " is empty - Deleting it"))
    (delete-directory-recursively! output-directory)))

(defn- task-not-found [task]
  ;; (main/abort (str "Subtask \"" subtask "\" not found."))
  )

;; Leiningen task
(defn haml
  "Runs the haml compiler plugin."
  {:help-arglists '([once auto clean])
   :subtasks [#'once #'auto #'clean]}
  ([project]
    (println
      (lhelp/help-for "haml"))
    ;; (exit-failure)
    )

  ([project subtask & args]
     (let [options (extract-options project)]
       (case subtask
         "once"  (once options)
         "auto"  (auto options)
         "clean" (clean options)
         (task-not-found subtask)))))


;; do (main/abort errors) on exception
