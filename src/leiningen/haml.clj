(ns leiningen.haml
  (:use leiningen.lein-haml.file-utils
        leiningen.lein-haml.render-engine)
  (:require [clojure.java.io   :as io]
            [leiningen.help    :as lhelp]
            [leiningen.clean   :as lclean]
            [leiningen.compile :as lcompile]
            [robert.hooke      :as hooke]
            ))

(def ^:private default-options {:haml-src "resources/haml"
                                 :output-extension "html"
                                 :delete-output-dir true
                                 :auto-compile-delay 250})

(def ^:private lein2?
  (try
    (require 'leiningen.core.main)
    true
    (catch java.io.FileNotFoundException _
      false)))

(defn- exit-success
  "Exit successfully in a way that satisifies lein1 and lein2."
  []
  (when-not lein2? 0))

(defn- exit-failure
  "Fail in a way that satisifies lein1 and lein2."
  []
  (if lein2?
    ((resolve 'leiningen.core.main/abort))
    1))

(defn- normalize-hooks [options]
  (let [hooks            (into #{} (:ignore-hooks options))
        normalized-hooks (if (:compile hooks) (conj hooks :once) hooks)] 
    (assoc options :ignore-hooks normalized-hooks)))

(defn- normalize-options [options]
  (->> options
       normalize-hooks
       (merge default-options)))

(defn- extract-options [project]
  (when (nil? (:haml project))
    (println "WARNING: no :haml entry found in project definition."))
  (normalize-options (:haml project)))


(defn- once
  "Compiles the haml files once"
  [options]
  (println (str "Compiling haml files in " (:haml-src options)))
  (render-all! options false))

(defn- auto
  "Automatically recompiles when files are "
  [options]
  (println (str "Ready to compile haml located in " (:haml-src options)))
  (render-all! options true))

(defn- clean
  "Removes the autogenerated files"
  [{:keys [haml-src output-directory output-extension delete-output-dir]}]
  (println "Deleting files generated by lein-haml.")
  (doseq [haml-descriptor (haml-dest-files-from haml-src {:dest output-directory :ext output-extension})]
    (delete-file! (io/file (:dest haml-descriptor))))
  (when (and delete-output-dir (exists output-directory) (dir-empty? output-directory))
    (println (str "Destination folder " output-directory " is empty - Deleting it"))
    (delete-directory-recursively! output-directory)))

(defn- task-not-found [subtask]
  (println (str "Subtask \"" subtask "\" not found."))
  (exit-failure))

;; Leiningen task
(defn haml
  "Compiles haml files."
  {:help-arglists '([once auto clean])
   :subtasks [#'once #'auto #'clean]}
  ([project]
     (println (lhelp/help-for "haml"))
     (exit-failure))

  ([project subtask & args]
     (let [options (extract-options project)]
       (case subtask
         "once"  (once options)
         "auto"  (auto options)
         "clean" (clean options)
         (task-not-found subtask)))))


;; Hooks stuffs
(defmacro hook [task subtask args]
  `(let [options# (extract-options (first ~args))]
     (apply ~task ~args)
     (when-not (~subtask (:ignore-hooks options#))
       (~(symbol (name subtask)) options#))))

(defn- compile-hook [task & args]
  (hook task :once args))

(defn- clean-hook [task & args]
  (hook task :clean args))

(hooke/add-hook #'lcompile/compile #'compile-hook)
(hooke/add-hook #'lclean/clean #'clean-hook)
