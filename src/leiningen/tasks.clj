(ns leiningen.tasks
  (:use leiningen.lein-haml-sass.render-engine
        leiningen.lein-haml-sass.options
        leiningen.lein-common.lein-utils))
;; Maybe don't need this (unless I find a better way to get the task functions
(def current-ns *ns*)

(defn- once-doc [src-type]
  (str "Compiles the " (name src-type) " files once"))

(defn- once [options]
  (let [type (name (:src-type options))]
    (println "Compiling" type "files located in" (:src options))
    (render-all! options false true)))


(defn- auto
  "Automatically recompiles when files are modified"
  [options]
  (let [type (name (:src-type options))]
    (println "Ready to compile" type "files located in" (:src options))
    (render-all! options true)))


(defn- clean
  "Removes the autogenerated files"
  [options]
  (let [type (name (:src-type options))]
    (println "Deleting files generated by lein" type)
    (clean-all! options)))


(defn- deps-doc [gem-name]
  (str "Installs the required " gem-name " gem"))

(defn- deps [options]
  (install-gem! options))


(defn- fn-meta [fn doc]
  (assoc (meta fn) :doc doc))

(defn- enrich-fn [fn doc]
  (with-meta fn (fn-meta fn doc)))

(defmacro def-lein-task [task-name gem-name]
  (let [type  (name task-name)
        src-type (keyword task-name)
        fname (symbol type)
        doc   (str "Compiles " type " files.")
        once-fn (enrich-fn once (once-doc src-type))
        deps-fn (enrich-fn deps (deps-doc gem-name))
        arg-list ['once 'auto 'clean 'deps]]
    `(defn ~task-name
       ~doc
       {:help-arglists '(~arg-list)
        :subtasks [~once-fn ~#'auto ~#'clean ~deps-fn]}
       ([~'project]
          (exit-failure (lhelp/help-for ~type)))

       ([~'project ~'subtask & ~'args]
          (if-let [options# (extract-options ~src-type ~'project)]
            (case ~'subtask
              "once"  (~once  options#)
              "auto"  (~auto  options#)
              "clean" (~clean options#)
              "deps"  (~deps  options#)
              (task-not-found ~'subtask))
            (exit-failure))))))

(defn- task-fn-for [subtask]
  ;;(ns-resolve current-ns (symbol (name subtask)))
  (case subtask
    :once  once
    :auto  auto
    :clean clean
    :deps  deps))

;; Hooks stuffs
(defmacro def-hook [hook-name src-type subtask]
  (let [task-fn (task-fn-for subtask)]
    `(defn- ~hook-name [task# & args#]
       (let [options# (extract-options ~src-type (first args#))]
         (apply task# args#)
         (when-not (~subtask (:ignore-hooks options#))
           (~task-fn options#))))))
